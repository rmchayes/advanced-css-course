/* animations */
/* moveInLeft is name of animation, not a keyword */
/* for performance reasons try to just change opacity and transform  */
@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-50rem); }
  80% {
    transform: translateX(1rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

/* animations */
/* moveInRight is name of animation, not a keyword */
/* for performance reasons try to just change opacity and transform  */
@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(50rem); }
  80% {
    opacity: 0.3;
    transform: translateX(-1rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

/* animations */
/* moveInBottom is name of animation, not a keyword */
/* for performance reasons try to just change opacity and transform  */
@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(-20rem); }
  90% {
    transform: translateY(1rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

@keyframes fadeIn {
  0% {
    opacity: 0; }
  100% {
    opacity: 1; } }

/* remember.....   : pseudo class, :: pseudo element */
/* universal selector, apply to all elements on page */
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  /* best practice */ }

/* rems not supported below IE9 */
html {
  /* default browser font size is 16px */
  /* therefore font-size 100% is 16px */
  /* but we want root font size for this page to be 16px, we want 10px */
  /* therefore 10/16 = 0.625 and our font size should be 62.5% of the */
  /* default browser font size. */
  font-size: 62.5%;
  /* 1 rem is the root font size of 10px */ }

/* body element selector. rest of body is in typography */
/* defines what 1 rem is... */
body {
  box-sizing: border-box; }

/* body element selector */
body {
  /* inherited by all child elements in the body. Don't put in universal selctor */
  font-family: "Lato", sans-serif;
  /* Lato google font, else sans-serif */
  font-weight: 400;
  /* font-size: 16px; */
  line-height: 1.7;
  color: #777;
  padding: 3rem; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  backface-visibility: hidden;
  /* fix text shake bug?! */
  margin-bottom: 6rem;
  /* helps move down btn */
  /* inherits from heading-primary */
  /* inherits from heading-primary */ }
  .heading-primary--main {
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    animation-name: moveInLeft;
    animation-delay: 0s;
    /* delay before starting animation */
    animation-duration: 2s;
    animation-iteration-count: 1;
    animation-timing-function: ease-in; }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.8rem;
    animation-name: moveInRight;
    animation-delay: 0s;
    /* delay before starting animation */
    animation-duration: 2s;
    animation-iteration-count: 1;
    animation-timing-function: ease-in; }

/* pseudo class "link" is a special state of a selector */
.btn {
  /* after pseudo element */ }
  .btn, .btn:link, .btnbtn:visited {
    text-transform: uppercase;
    text-decoration: none;
    /* get rid of default link underline */
    padding: 1.5rem 4rem;
    /* top bottom 15px, left right 40px */
    /*padding: 15px 40px 15px 40px; alternatively top right bottom left */
    display: inline-block;
    /* use inline-block instead */
    border-radius: 10rem;
    transition: all 0.2s;
    position: relative;
    font-size: 1.6rem;
    border: none;
    cursor: pointer; }
  .btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 1rem 2rem rgba(34, 8, 124, 0.7); }
    .btn:hover::after {
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0; }
  .btn:active {
    outline: none;
    transform: translateY(-1px);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.7); }
  .btn--white {
    background-color: #fff;
    color: #777;
    /* create "splash" effect */ }
    .btn--white::after {
      background-color: #fff; }
  .btn::after {
    content: "";
    /* must always include content keyword, even if empty */
    display: inline-block;
    /* should be same as btn:link*/
    height: 100%;
    width: 100%;
    border-radius: 10rem;
    /* abolute positioning needs to have a reference. That reference is the first relative element it can find. In this case it would be the header (see html for hierarchy) but we don't want it to be the header. We want it to be hidden after the button, so the reference should be the button. Therefore we have to set the position property of the button to relative. (see btn:link) */
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    /* depth of elements, negative is lower in the layer */
    transition: all 0.4s; }
  .btn--animated {
    animation: moveInBottom .65s ease-in 2s;
    animation-fill-mode: backwards; }

.btn-text:link, .btn-text:visited {
  font-size: 1.6rem;
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 3px;
  transition: all .2s; }

.btn-text:hover {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  transform: translateY(-2px); }

.btn-text:active {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  transform: translateY(0); }

.header {
  height: 95vh;
  /* 95% of the viewport */
  background-image: linear-gradient(to right bottom, rgba(111, 206, 213, 0), #22087c), url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  position: relative;
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%); }
  .header__logo-box {
    position: absolute;
    top: 4rem;
    /* top and left relative to parent element (header) See html*/
    left: 4rem; }
  .header__logo {
    height: 3.5rem;
    /* width automatically calculated */ }
  .header__text-box {
    position: absolute;
    /* top and left relative to parent element (header) */
    top: 40%;
    left: 50%;
    /* centre the heading box, relative to element itself, not parent*/
    transform: translate(-50%, -50%);
    text-align: center; }

.row {
  /* means that if we have enough available width in the viewport then it will have the width that we specified 114rem. if there's not enough width (ie: the viewport is smaller than 114rem) then it will simply fill 100% of the space available. */
  max-width: 114rem;
  background-color: #ccc;
  margin: 0 auto; }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    content: "";
    display: table;
    clear: both; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2);
    background-color: orangered;
    float: left; }
    .row .col-1-of-2:not(:last-child) {
      margin-right: 6rem; }
